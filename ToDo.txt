Notes
	PEGTL Submodule interactions can only be done with the Git Shell
	For updating the local PEGTL repository
		In Git Shell, navigate to "Visual Studio 2015/MyResources/MyLib"
		Currently, delete the existing PEGTL directory
		Execute "git clone https://github.com/ColinH/PEGTL.git"
	Using newline in repl/testing
		Just add "\n" in the automated tests (although the display is wonky)
		For the repl loop, use getmultiline
			getmultiline waits until [ENTER] is hit twice before accepting

Opinions on adapting code to use the C++ Common Code Standards and the GSL
	I feel like this would be a good idea on the whole
		I currently can't explain why though

	However there are many downsides the mean I won't implement it yet
		Time-costly to go through and implement for the whole project
			This will only get worse as time goes on however
		I'm not used to the new standards
			Error prone if I perform the switch while I'm figuring this stuff out
			If I don't understand my current code at times, how can I accurately adapt it to the new standard?
		Some of	the juicy stuff is not available yet (static analyzers)

Timeline
	0 Bugfixes / Improvements
		Improvements to the Testing suite
			Handling of non-printable values, specifically tables and nil
				Currently have to require_true of a comparison
				Could just use "require_type" for these (or the type checking syntax)
			Add table specific functions (?)
			"Global Review" is duplicated at the end, consider removing it
			Consider splitting test sections (see comments in Testing.h)
			Add comments to each test describing what's being tested
		Consider removing the test for operator isDefd in com
			Would remove ambiguity in code execution
			"3" - 3 => String._op- not defined
				This would likely mean I can improve com lookup implementation
		Improve the implementation of GC
		Think of changing how operator resolution is handled (especially for equals)
			Currently "[3] = 3" evaluates to true
			Consider adding "metadata" (such as com_t when calling other operators ???)
		Change tables to copy-on-write semantics
			Currently tables are references (ie. pointers)
				This is passable but not what I want from the language
		Redo how get/set are handled (in relation to exception throwing)
			Ensure that EvalState::setVar static typing works correctly (I think it's currently bidirectional, should be unidirectional)
		Check on changing ts.convertible(t1, t2) to ts.convertible(f, t)
			Basically stopping convertible(a, b) = convertible(b, a) from always being true
			Where did I want to change this from (EvalState::setVar)
		Implement Table::okayKey and Table::okayValue and provide a way to change behavior
			These methods are how "3: 3" will be prevented in the global scope and allowed in tables
				Change the expected exception on Testing:line 99 once implemented
			Also allow for restricting key and values based on given functions
		Implement Console manipulators for mac and linux
			Apparently both use ansi color codes
		Clean up the code for the testing framework
		Parser Issues
			Unsure about behavior of action<c_paren> for empty parentheses
			Speed up the performance of parsing line
				Currently has to read eval_line twice to ensure correctness
			Minimize the cost of specializing Control (too many declarations)
				Check the documentation first, I might be missing something there
			Consider rearranging/repurposing actions to provide better parser data
		Start reading up on the gsl
			Try converting some code once I understand it
		Various Changes
			Change 0 => false ???
		See VagueToDo.txt
				
	1 Control Statements
		Allow control strutures to "assign" variables
			Test on Try-Catch statements (error message test)
		Implement For statement
			Basic table ranges ([1..5] and [1, 3..5])

	2 Function Calling		ie. print("Hello, World!")
		Be able to store functions as values
			Create the necessary Collector structure (needs to handle C++ functions/lambdas and dust AST's)
			Get assignment to work as expected with functions
		Implement the evaluation hooks/etc. to be able to call functions	# Get functions callable
			Hard coded translations at this time
			Have the basic syntax and semantics working (Argument passing, etc.)
		Convert Types completely to impl::Table for storage concerns
			Allow Type methods to be called using '.'/'[]' syntax on non-table values and variables
				Current AST construction assumes a VarName node exists (not guaranteed for non-variables)
			Allow Type methods to be called using '.'/'[]' syntax
				Current grammar disallows type_ids to be used outside of new_type and type_checking
		Move function calling work into the _op() metamethod
			_op() expects a l->r stack (function on top, first argument at -2, etc.)
			Push arguments from r->l on the stack
			Get function value on the stack
			Call _op() on the function
		Optional: No parens syntax

	3 Dust Function Definition
		Update project version to 0.8.1
		Abstract the previous framework to allow for Dust functions to be conceivably executed
		Add in the correct syntax and action calls to create dust functions
		Convert tables away from pure references
			Particularly important for functions
		Start to implement type methods

	4 Grammar Framework Update
		Potentially change the grammar to follow the basic framework in "lua53_parse.h"
		Update all documents to ensure that they reflect the current language spec
		Update the readme to show of recent aditions
		Determine the next set of features that need to be implemented
		Bugfixes

	5 Type/Table metamethods



Notes (In case I forget some of my decisions)
	3 + e: 4	=> (3 + e)[: 4]		/> (3 + (e: 4))		// To difficult to modify the grammar. I can't find anywhere that I expected it
	(e: 3) + 3 * e = 12									// The assignment is evaluated before the multiplication (left->right evaluation). This has some problems with current organization
	a, b:+ 2											// I'm going to go with the current semantics for now for simplicity. However, it still possible for it to be changed in the future
	a, b: b, c: 9										// Again, I'm going to use the current semantics for simplicity. There also would be difficulty in correctly parsing it otherwise due to the overlap and the fact that an assignment is an expression
	Nil is defined as Bool for the sake of operator resolution (something to watch out for?)