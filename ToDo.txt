Notes
	PEGTL Submodule interactions can only be done with the Git Shell
	For updating the local PEGTL repository
		In Git Shell, navigate to "Visual Studio 2015/MyResources/MyLib"
		Currently, delete the existing PEGTL directory
		Execute "git clone https://github.com/ColinH/PEGTL.git"
	Using newline in repl/testing
		Just add "\n" in the automated tests (although the display is wonky)
		For the repl loop, use getmultiline
			getmultiline waits until [ENTER] is hit twice before accepting

Opinions on adapting code to use the C++ Common Code Standards and the GSL
	I feel like this would be a good idea on the whole
		I currently can't explain why though

	However there are many downsides the mean I won't implement it yet
		Time-costly to go through and implement for the whole project
			This will only get worse as time goes on however
		I'm not used to the new standards
			Error prone if I perform the switch while I'm figuring this stuff out
			If I don't understand my current code at times, how can I accurately adapt it to the new standard?
		Some of	the juicy stuff is not available yet (static analyzers)

Timeline
	1 Scoping and multi-lined grammar
		Modify the grammar to accept multiple lines
			
			Have the input "evaluate" to the value of the last line														# How to handle multiline evaluation
				A block of code is equivalent to a vector of Expressions (ASTNodes)
				To evaluate the block, I iterate over the expressions
					Before block evaluation the stack will have x elements
					Before evaluating each expression, set stack top to x
						The evaluate the requisite expression
						Because the last expression has no following expression, it's values are left on the stack
							Break/Continue may give some problems with this model
					I have a general conception in AST

		Be able to create and parse scopes using tabbing																# How to implement Scoping
			Add "do" keyword recognition
				Possibly enforce having a new scope follow use
			Figure out how I'm going to store scopes for execution
				Temporary v. Static Scopes (Loops v. Functions, etc.)
					Temporary scopes are not stored in memory, Static scopes are
						Temporary scopes are created and destroyed as needed
					Will I even be having static scopes (Scopes that are stored)

			Unify the ability to break expressions onto multiple aligns with whitespace for scoping						# Handling important whitespace
				Continuation expressions
					sep = one<' ', '\n', '\t'>
						I could also keep sep as is and provide a c_sep/etc. that allows continuation expressions
					Then any expression that allows a seps (c_seps) to exist on multiple lines and be parsed correctly
						Can have one portion on one line and the rest on another, idented 5 levels
						This part of the expression would ignore any scoping levels (logically it is a part of the previous line)

				Indexing on multiple lines
					The question is really whether "foo() . bar . call()" should equal "foo().bar.call()"
						With the concept of "continuation expressions", "foo()\n.bar\n.call()" is a natural side effect of allowing the above
							And moreover doesn't require any changes in grammar/parsing/etc. (aside from sep)

			Determine the difference between a tab and x spaces															# Scoping whitespace rules
				How does Python resolve this problem
					Requiring a ':' to begin a new scope (ie. do keyword)?
						But what about lambdas
					Line joining
						Python uses the '\' character to join physical lines into logical lines
					Space and tab are different characters
						Scoping is only introduced with tabs
					Copy-paste
						Translate all tabs to spaces (or vice versa) before parsing

		Implement scoped declarations and access
			ModifyEvalState to use scoping to store variables
			Implement global and local variable distinction				## be able to access "masked" variables

		Possibly replace global variable storage with the scoping structures/mechanisms
			Good way of implementing namespaces/modules (map from string -> scope)
				Normal "scoping" would use a stack (defaults to empty)
			Could scoping also be used for tables ???

	2 Type Definitions
		Have the ability to create new types and assign inheritance relationships
		Have some interaction with type ids, if only for debugging purposes
		Add a basic recognition of Table syntax (no semantical influence yet)
	3 Table Semantics
		Indexable arrays
		Determine how to access the arrays
		Assigning values to the arrays
		_nindex and _index metamethods
		Arrays -> Tables (any key)
		Empty Table => false
	4 Keyword Recognition
		Update pegtl library
		Get the grammar to recognize various keywords
		Work on the framework for adding keywords to the AST
			BinaryKeyword is a temporary addition to test and/or
		Possibly clean up EvalState and Grammar
	5 Exception and Error update
		Update exceptions and errors to better fit the new features
		Add exception catching and error functions
		Add throw/catch (or whatever I call it in dust) functionality
			I won't have the syntax yet though
		Improve Exception Error Messages
			Mainly work on Exception constructors
	6 Strict Parser Update
		Update the parser so that wrong programs will ouput an error (as opposed to interpreting a subset)
	7 Function Calling		ie. print("Hello, World!")
		Basic syntax and semantics (Argument passing, etc.)			## Get functions callable
		Can assign functions and then call the assigned function	## a = print and a(3)
			Would this necessitate having _op() syntax work be done???
		_op() syntax (Metamethods ???)
		Optional: No parens syntax
	8 Keyword Framework Update
		Potentially change the grammar to follow the basic framework in "lua53_parse.h"
	9 Scoping Improvement Work
	10 Control Structures
	11 Table definition (This can go before scoping)
	12 Function definition (no lambdas)
	13 Metamethods (converting syntax into function calls)
	...

Other
	Exceptions and error handling
		Stack out of data
		No defined conversion
		...
	Make the parser reject ill-formed input
	String escape characters

Notes (In case I forget some of my decisions)
	3 + e: 4	=> (3 + e)[: 4]		/> (3 + (e: 4))		// To difficult to modify the grammar. I can't find anywhere that I expected it
	(e: 3) + 3 * e = 12									// The assignment is evaluated before the multiplication (left->right evaluation). This has some problems with current organization
	a, b:+ 2											// I'm going to go with the current semantics for now for simplicity. However, it still possible for it to be changed in the future
	a, b: b, c: 9										// Again, I'm going to use the current semantics for simplicity. There also would be difficulty in correctly parsing it otherwise due to the overlap and the fact that an assignment is an expression