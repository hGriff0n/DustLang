Notes
	PEGTL Submodule interactions can only be done with the Git Shell
	For updating the local PEGTL repository
		In Git Shell, navigate to "Visual Studio 2015/MyResources/MyLib"
		Currently, delete the existing PEGTL directory
		Execute "git clone https://github.com/ColinH/PEGTL.git"
	Using newline in repl/testing
		Just add "\n" in the automated tests (although the display is wonky)
		For the repl loop, use getmultiline
			getmultiline waits until [ENTER] is hit twice before accepting

Opinions on adapting code to use the C++ Common Code Standards and the GSL
	I feel like this would be a good idea on the whole
		I currently can't explain why though

	However there are many downsides the mean I won't implement it yet
		Time-costly to go through and implement for the whole project
			This will only get worse as time goes on however
		I'm not used to the new standards
			Error prone if I perform the switch while I'm figuring this stuff out
			If I don't understand my current code at times, how can I accurately adapt it to the new standard?
		Some of	the juicy stuff is not available yet (static analyzers)

Timeline
	0 Bugfixes / Improvements
		Nil method resolution still needs work (esp. in callMethod)
			The current process might catch some functions that shouldn't work on Nil types
		The numRefs in the String/Table Storage classes are messed up
			d: "Hello" => gc.numRefs("Hello") = -1		## Should be 1
				References are being decremented too readily
			d: [ 5 6 7 ] d: 3 => gc.numRefs([ 5 6 7 ]) = 1		## Should be 0
				References aren't decremented at all
				See CallStack ???
			Ensure that this is correct
		** Need to adapt Testing to handle non-printable values
			Could just use "require_type" for these (or the type checking syntax)
		Need to ensure scope exiting handles reference decrementing properly
		Start testing TRuntimeStorage and improving implementation
		Improve testing suit with table specific functions (?)
		Consider removing the test for operator isDefd in com
			Would remove ambiguity in code execution
			"3" - 3 => String._op- not defined
		Improve the implementation of GC
		Determine whether 0 should be equal to true or false
		Think of changing how operator resolution is handled (especially for equals)
			Currently "[3] = 3" evaluates to true
			Consider adding "metadata" (such as com_t when calling other operators ???)
		Fix "3: 3" throwing errors (inside of table definitions)
			"3" is considered to be a VarName (which is expected by Assign::var_type)
				Assign actually needs the set method (although this could *possibly* be redone if it's too bad)  ???
		Change tables to copy-on-write semantics
			Currently tables are references (ie. pointers)
				This is passable but not what I want from the language
		Consider getting a static analyzer
		Redo how get/set are handled (in relation to exception throwing)
		See VagueToDo.txt

	1 Keyword Recognition
		Halve the Bugfixes/Improvements list

	2 Parser Update
		Exceptions
			Update exceptions and errors to better fit the new features
			Add exception catching and error functions
			Improve Exception Error Messages
				Mainly work on Exception constructors
		Table Improvements
			Figure out where to add in hooks to allow for restricting key/value types in tables
				Force "3: 3" to throw a dust_error (when performed in the global scope)
					Throw for a different reason than current execution
				Would need to add the type system (as an argument or something)
		Update the parser so that wrong programs will ouput an error (as opposed to interpreting a subset)
			I may have already done this (although I could make the errors more informative)
		Possibly start implementing custom Control specializations (standardize error types)
		Standardize code standards
			classes: PascalCase (?)
			methods: camelCase (?)
			variables: snake_case (?)
		Improve expr_4 grammar to be more accurate (?)
			ee_tc can't realistically be performed more than once in a row (outside of testing for Bool)
				I could also have the result of evaluation be the left hand side (this doesn't make much sense)

	3 Parser Rewrite v. II
		Redo how scoping is handled by the parser
			Rewrite table/block/try-catch to allow for declaring across multiple lines
			Should also simplify the grammar in general (work to this as well)
		Rewrite the parser so that everything works well together

	4 Control Statements (For/While/Do-While/If/Else/...)
		Be able to write control statements with correct execution
			Have variable scoping work correctly

	5 Function Calling		ie. print("Hello, World!")
		Implement the evaluation hooks/etc. to be able to call functions	# Get functions callable
			Hard coded translations at this time
			Have the basic syntax and semantics working (Argument passing, etc.)
		Be able to store functions as values
			Get assignment to work as expected with functions
		Convert Types completely to impl::Table for storage concerns
			Allow Type methods to be called using '.'/'[]' syntax
				Current grammar disallows type_ids to be used outside of new_type and type_checking
			Allow Type methods to be called using '.'/'[]' syntax on non-table values and variables
				Current AST construction assumes a VarName node exists (not guaranteed for non-variables)
		Move function calling work into the _op() metamethod
		Optional: No parens syntax

	6 Dust Function Definition
		Abstract the previous framework to allow for Dust functions to be conceivably executed
		Add in the correct syntax and action calls to create dust functions

	7 Grammar Framework Update
		Potentially change the grammar to follow the basic framework in "lua53_parse.h"
		Update all documents to ensure that they reflect the current language spec
		Update the readme to show of recent aditions
		Determine the next set of features that need to be implemented

	8 Type/Table metamethods



Notes (In case I forget some of my decisions)
	3 + e: 4	=> (3 + e)[: 4]		/> (3 + (e: 4))		// To difficult to modify the grammar. I can't find anywhere that I expected it
	(e: 3) + 3 * e = 12									// The assignment is evaluated before the multiplication (left->right evaluation). This has some problems with current organization
	a, b:+ 2											// I'm going to go with the current semantics for now for simplicity. However, it still possible for it to be changed in the future
	a, b: b, c: 9										// Again, I'm going to use the current semantics for simplicity. There also would be difficulty in correctly parsing it otherwise due to the overlap and the fact that an assignment is an expression