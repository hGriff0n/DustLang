Notes
	PEGTL Submodule interactions can only be done with the Git Shell
	For updating the local PEGTL repository
		In Git Shell, navigate to "Visual Studio 2015/MyResources/MyLib"
		Currently, delete the existing PEGTL directory
		Execute "git clone https://github.com/ColinH/PEGTL.git"
	Using newline in repl/testing
		Just add "\n" in the automated tests (although the display is wonky)
		For the repl loop, use getmultiline
			getmultiline waits until [ENTER] is hit twice before accepting

Opinions on adapting code to use the C++ Common Code Standards and the GSL
	I feel like this would be a good idea on the whole
		I currently can't explain why though

	However there are many downsides the mean I won't implement it yet
		Time-costly to go through and implement for the whole project
			This will only get worse as time goes on however
		I'm not used to the new standards
			Error prone if I perform the switch while I'm figuring this stuff out
			If I don't understand my current code at times, how can I accurately adapt it to the new standard?
		Some of	the juicy stuff is not available yet (static analyzers)

Timeline
	0 Bugfixes / Improvements
		Nil method resolution still needs work (esp. in callMethod)
			The current process might catch some functions that shouldn't work on Nil types
		Need to adapt Testing to handle non-printable values
			Could just use "require_type" for these (or the type checking syntax)
		Improve the usefulness of the Testing suite by adding a review of the status of all (global) tests that were run
			Possibly add in sub-test reviews if able
			Could also replace the last statement of the run_tests
		Clean up code
			Block::eval
			Try to reduce the number of ASTNodes
		The numRefs in the String/Table Storage classes are messed up
			Ensure that this is correct
		Improve the implementation of GC
			Possibly convert RuntimeStorage to be templated
		Consider adding a new field to impl::Value, 'idu'
			Determines selection of i/d/u fields for low-level code (operator<(impl::Value))
			Could also just delay definition until TypeTraits is specified
		Determine whether 0 should be equal to true or false
		Modify '.' to interpret a integer if the key is numeric
			Would first need to modify the grammar so that parses (without error)
		See VagueToDo.txt

	1 Table Semantics (need to rework the breakdown chart)
		Generalize Scope into Array
			Enable '[]' syntax for accessing tables with variables and literals
				Modify VarName to allow for non-variable sub-steps
					Change eval to have a "unnecessary" bool arg that defaults to true
					This arg is only considered by VarName nodes (as push(name))
						But what about "a.b[b.c]" VarName{ a, VarName{ b }, VarName{ b, c } }
							Only if sub_field.size() == 0 ???
				Determine why "3: 3" throws errors (inside the global scope and tables)
					Then stop the error from occurring
				Work on improving Table's api (and how interaction is handled by the interpreter)
					This is particularly important with regards to "appending" to the table (uses the next open int)
			Implement some table operators
			Implement _nindex and _index metamethods (internally)
				Possibly start to add in evaluation hooks
		Generalize Array into Table
			Generalize Table to be able to use keys of any types
				Add in the capability (internally) to restrict key types (?)
					Cause "3: 3" to throw a dust_error (when performed in the global scope)
			Determine whether tables are references or copy-on-write
				Current semantics is references
			Convert Types to have an impl::Table storage member
				Can't completely convert yet (functions aren't implemented)
			Add in some API functions
				Possibly be able to index non-table values (to access type members)
			Complete operator overload implementations
		Generalize '.' syntax even further
			Allow for non-table values/variables to index type members with '.'
			Allow for type names to be indexable with '.'
		 
	2 Keyword Recognition
		Update pegtl library
			Possibly include the GSL as a submodule
			Look for more libraries
		Get the grammar to recognize all keywords (in correct precedence)
			Prevent keywords from being recognized as variables in certain situations
				This doesn't occur for true and false (literals are matched first)
		Work on the framework for adding keywords to the AST
			BinaryKeyword is a temporary node to test and/or
		Possibly clean up EvalState and Grammar
		Update the ReadME to account for the recent additions

	3 Exception and Error update
		Update exceptions and errors to better fit the new features
		Add exception catching and error functions
		Improve Exception Error Messages
			Mainly work on Exception constructors

	4 Strict Parser Update
		Update the parser so that wrong programs will ouput an error (as opposed to interpreting a subset)
			I may have already done this (although I could make the errors more informative)
		Possibly start implementing custom Control specializations (standardize error types)
		Standardize code standards
			classes: PascalCase (?)
			methods: camelCase (?)
			variables: snake_case (?)
		Improve expr_4 grammar to be more accurate (?)
			ee_tc can't realistically be performed more than once in a row (outside of testing for Bool)
				I could also have the result of evaluation be the left hand side (this doesn't make much sense)

	5 Function Calling		ie. print("Hello, World!")
		Be able to store functions as values
		Convert Types completely to impl::Table for storage concerns
			Make Types indexable much like tables
		Basic syntax and semantics (Argument passing, etc.)			## Get functions callable
		Can assign functions and then call the assigned function	## a = print and a(3)
			Would this necessitate having _op() syntax work be done???
		_op() syntax (Metamethods ???)
		Optional: No parens syntax

	6 Grammar Framework Update
		Potentially change the grammar to follow the basic framework in "lua53_parse.h"
		Update all documents to ensure that they reflect the current language spec
		Update the readme to show of recent aditions
		Determine the next set of features that need to be implemented



Notes (In case I forget some of my decisions)
	3 + e: 4	=> (3 + e)[: 4]		/> (3 + (e: 4))		// To difficult to modify the grammar. I can't find anywhere that I expected it
	(e: 3) + 3 * e = 12									// The assignment is evaluated before the multiplication (left->right evaluation). This has some problems with current organization
	a, b:+ 2											// I'm going to go with the current semantics for now for simplicity. However, it still possible for it to be changed in the future
	a, b: b, c: 9										// Again, I'm going to use the current semantics for simplicity. There also would be difficulty in correctly parsing it otherwise due to the overlap and the fact that an assignment is an expression