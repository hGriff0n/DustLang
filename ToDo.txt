Notes
	PEGTL Submodule interactions can only be done with the Git Shell
	For updating the local PEGTL repository
		In Git Shell, navigate to "Visual Studio 2015/MyResources/MyLib"
		Currently, delete the existing PEGTL directory
		Execute "git clone https://github.com/ColinH/PEGTL.git"
	Using newline in repl/testing
		Just add "\n" in the automated tests (although the display is wonky)
		For the repl loop, use getmultiline
			getmultiline waits until [ENTER] is hit twice before accepting

Opinions on adapting code to use the C++ Common Code Standards and the GSL
	I feel like this would be a good idea on the whole
		I currently can't explain why though

	However there are many downsides the mean I won't implement it yet
		Time-costly to go through and implement for the whole project
			This will only get worse as time goes on however
		I'm not used to the new standards
			Error prone if I perform the switch while I'm figuring this stuff out
			If I don't understand my current code at times, how can I accurately adapt it to the new standard?
		Some of	the juicy stuff is not available yet (static analyzers)

Timeline
	0 Bugfixes
		Fix Bug involving scopes and assignments
			Any assignment based tests are currently broken (Don't "stick")
				Exceptions don't "unroll" scoping
				I have a solution, I just need time to thing on its efficacy
					The solution provides for handling dust exceptions in dust
			Move the work on require/etc. into "File Evaluation.txt"
		Possibly improve the Testing System code
		Comments cause parser errors
		Improve the usefulness of the Testing suite by adding a review of the status of all (global) tests that were run
			Possibly add in sub-test reviews if able
			Could also replace the last statement of the run_tests

	1 Scoping and multi-lined grammar
		Move EvalState to be able to have multiple scopes
			Need to have a "global" scope
				This is primarily a problem with Block eval
				Add flags to Block (set to true if main Block)
					This is a (probable) problem with including files

					require = {req_assign}?require {string}
						req_assign = {var_id}: *

					Require loads the file given by the string into a table
						Evaluation is performed as a block object, the scope is not deleted after evaluation
							This needs a seperate flag from global

						The table is then assigned to the variable given in req_assign
							If a req_assign is not given, the var_name is created from the file string
							If a req_assign is not given, the assignment is performed in the global scope

							Ex. g: require "graph"
								require "graph"				## equivalent to "_G.graph: require "graph""
								print(g = graph)			## true

						Loading files therefore uses a different scoping system from the including file
						If the file is already loaded, require reuses the loaded table
							Might delete the tables if no longer referenced

					Implementation General Ideas
						For evaluating files
							Starting a file evaluation requires the creation of a new scope
							Ending a file's evaluation entails the deletion of the scope (unless require'd)
								However the "global" scope is kept seperate from this system and is not deleted
								Also used to "initialize" the deep scoping

						For parsing require
							Require evaluation flags its constructed Block's "required" field, before evaluating the Block
							This field changes the scope deletion into a scope storage (which is then used for assignment)
					
					How will modules work
						Modules is just a way of specifying which "functions" and "variables" are visible to a user of the table
						Could possibly be implemented using metamethods (Add at file end)

		Ensure that EvalState decrements references correctly
			Improve the implementation of EvalState methods
		Add scope api to EvalState
			Block can use EvalState to create/destroy/store scopes
		Implement scoped variable lookup
		Generalize RuntimeStorage and GC to be able to work with Scope
		Better specify how scoping is handled
		Solve the problem with analysis
			Analysis says there's an infinite loop with block (probably because I don't know what I'm doing with that stuff)
			problem: cycle without progress detected at class struct dust::parse::block

		How to define Scoping
			Determine the difference between a tab and x spaces															# Scoping whitespace rules
				How does Python resolve this problem
					Requiring a ':' to begin a new scope (ie. do keyword)?
						But what about lambdas
					Line joining
						Python uses the '\' character to join physical lines into logical lines
					Space and tab are different characters
						Scoping is only introduced with tabs
					Copy-paste
						Translate all tabs to spaces (or vice versa) before parsing

		Be able to create and parse scopes using tabbing
			block is currently a "non-recoverable" node (you can't recover from failures during parsing)

			Possible program change
				Change the NEW_SCOPE debug node used to stop Block combination to a Control node
					The default NEW_SCOPE node will become a "run once" Control node
					Loops and (possibly) branches will act as the control node
				This Control node handles how the block is run
					"run once" is analagous to Block::eval
					"for" rather translates into something like while (For::eval) Block::eval
					This might have some problems with evaluating while versus do-while
				This removes using program resources on completely useless operations
					Except maybe not (Block construction might stop on an inner loop)

			How am I going to store scopes
				Temporary v. Static Scopes (Loops v. Functions, etc.)
					Temporary scopes are not stored, Static scopes are
						Temporary scopes are created and destroyed as needed

	2 Type Definitions and Table Syntax
		Have the ability to create new types and assign inheritance relationships
		Have some interaction with type ids, if only for debugging purposes
		Add a basic recognition of Table syntax (the grammar accepts tables)
			Possible Table Implementation
				Have the Table ASTNode inherit from Block
				Table::eval sets a scope, then calls Block::eval, which sets the variables in the scope
					However, there's problems in setting default keys
						It's a simple question of Assign vs. ASTNode
						If the node is castable to Assign, then it doesn't need the default key
							Printing is still a problem
							Would ',' then become an expression seperator (outside of the list functionality) ???
							There's also the implications on the range syntax (would this need tables)
				Then Table = [ <expr>* ] (instead of [ <arg_list> ])
	3 Table Semantics
		Indexable arrays
		Determine how to access the arrays
		Assigning values to the arrays
		_nindex and _index metamethods
		Arrays -> Tables (any key)
		Empty Table => false
	4 Keyword Recognition
		Update pegtl library
		Get the grammar to recognize various keywords
		Work on the framework for adding keywords to the AST
			BinaryKeyword is a temporary addition to test and/or
		Possibly clean up EvalState and Grammar
	5 Exception and Error update
		Update exceptions and errors to better fit the new features
		Add exception catching and error functions
		Add throw/catch (or whatever I call it in dust) functionality
			I won't have the syntax yet though
		Improve Exception Error Messages
			Mainly work on Exception constructors
	6 Strict Parser Update
		Update the parser so that wrong programs will ouput an error (as opposed to interpreting a subset)
	7 Function Calling		ie. print("Hello, World!")
		Basic syntax and semantics (Argument passing, etc.)			## Get functions callable
		Can assign functions and then call the assigned function	## a = print and a(3)
			Would this necessitate having _op() syntax work be done???
		_op() syntax (Metamethods ???)
		Optional: No parens syntax
	8 Keyword Framework Update
		Potentially change the grammar to follow the basic framework in "lua53_parse.h"
	9 Scoping Improvement Work
	10 Control Structures
	11 Table definition (This can go before scoping)
	12 Function definition (no lambdas)
	13 Metamethods (converting syntax into function calls)
	...

Other
	Exceptions and error handling
		Stack out of data
		No defined conversion
		...
	Make the parser reject ill-formed input
	String escape characters

Notes (In case I forget some of my decisions)
	3 + e: 4	=> (3 + e)[: 4]		/> (3 + (e: 4))		// To difficult to modify the grammar. I can't find anywhere that I expected it
	(e: 3) + 3 * e = 12									// The assignment is evaluated before the multiplication (left->right evaluation). This has some problems with current organization
	a, b:+ 2											// I'm going to go with the current semantics for now for simplicity. However, it still possible for it to be changed in the future
	a, b: b, c: 9										// Again, I'm going to use the current semantics for simplicity. There also would be difficulty in correctly parsing it otherwise due to the overlap and the fact that an assignment is an expression