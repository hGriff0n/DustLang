	def quick(sel)
		sel <- Table and quick(*sel) or sel		## type(sel) = "table"

	def quick(sel, *list)				## Splat operator
		mid, high: [sel], low: []
		for item in list
			switch item <=> sel			## works similar to Java's compareTo
				@high :+ item, if 1
				@low :+ item, if -1
				@mid :+ item, otherwise
		[quick(low), mid, quick(high)].flatten()

	def quick([sel, *list])				## overloading not needed with pattern matching (only accepts tables though)
		if !list return sel
		mid: [sel]						## how about 'mid, high: [sel], low: []'
		high: low: []					## the question is about evalutation order (does low: get evaluated before high:)
		for item in list
			switch item <=> sel			## the omni-sign is not valid syntax yet
				@high :+ item, if 1
				@low :+ item, if -1
				@mid :+ item
		[*quick(low), *mid, *quick(high)]	## you can also use splat instead of flatten