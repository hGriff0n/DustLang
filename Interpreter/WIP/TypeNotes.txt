
Dust Type System

Shorthand
	Given types 'a' and 'b'
		a < b indicates that a is a child of b					## These may end up becoming part of the language syntax/semantics
		a = b indicates that a is the same type as b
		a > b indicates that a is a parent of b

Variables in dust are dynamically typed
	By default, they can store a value of any type

	There exists syntax to perform static typing of variables
		Quick definitions
			's' is the static type of the variable

		Dust static typing primarily works by providing an assurance that the variable holds a usable value (ie. not nil)
			There is no current push to use this typing information to perform code optimizations (the language is foremost dynamic)
			Static typing variables (not in function declarations) could throw an error if the variable was uninitialized

		Statically typed variables can naturally hold values of any types a, where a <= s
			Currently, this is performed by having both Variable and Value maintain a type_id field
				The default value of Variable::type_id is NIL

Inheritance and the Type Heirarchy
	Currently, Dust uses single inheritance to organize the type heirarchy
		I just cannot safely reason about, and ensure the correctness, of multiple inheritance dispatch and indexing
		This may end up causing some problems with implementing custom types
			The current syntax allows a type_list after the inheritance operator

	Inheritance dispatch
		A method is considered inherited if it's definition can only be found in a parent's type
			A method that is defined on the type is considered locally/immediately defined
				For the purposes of inheritance dispatch, locally defined methods are inherited

		Inheritance dispatch seeks to find the type b where a given method is locally defined given type a, where a <= b, and method c
			Dispatch works by checking if the method is locally defined on the type
				If yes, returns the type
				If not, tries again on parent(type)
			Dispatch results in NIL if the given method was not defined by the type

Common Type and Operator dispatch
	It is possible to overload operators for custom types in dust
		All instances of operators are translated to a _op or _ou call in a type table
			Defining/Overloading these functions can enable custom behavior
			The question then becomes how to determine which type table to select, particularly when the two operands are different types
				ie. Should "3 + 3.5" equal 6 (Int._op+) or 6.5 (Float._op+)
	
	Common Type is a method for resolving this dispatch
		The key reasoning behind common type is that operators should only work on two objects of the same type
			And for the operators that Dust allows to be overloaded, this holds relatively true
			Then the goal of common type resolution is to find a type that both operands can take on (either through conversion or inheritance) and overloads the operator
				However ensuring that the common type overloads the operator is not explicitly necessary as it can be handled through inheritance dispatch

		Moreover, common type resoultion should be a transitive operation
			This is more a factor of matter of minimalizing the process of overloading operators within dust
				No need to define multiple overloads depending on lhs and rhs
				The restriction on same type also seeks to minimize this process
			What this means is that 3 + "Hello" should call the same method as "Hello" + 3
				ie. com(l, r, op) = com(r, l, op)

		Common Type resoultion is implemented in "TypeSystem::com"
			The procedure is realtively simple and straightforward
				First check whether the two are the same type
					This step's not entirely necessary, however it's a quick and simple optimization
				Then check if there exists a converter between the two types (Converter Resolution)
					This step will only return if the operator is defined in the converter's 'to' type
					Note: converters must be immediately defined (ie. not inherited) to be selected
				Finally return the common ancestor of the two types (Common Ancestor)

		Converter Resolution
			The idea for converter resolution is that if a defines a converter to b, than the intended meaning of a + b is likely type(b)._op+(a, b)

			However, there are some slight complications, especially if both types define converters to the other
				To resolve this complication, converters have an implicit rating of precedence
					If precedence(a->b) < precendence(b->a), then the intended meaning of a + b is likely type(a)._op+(a, b)
						precedence is a relative figure (it only exists in any comparable meaning among converters between two types)
							ie. precedence(a->b) and precedence(c->d) have no useful comparison
						Note that two converters cannot have the same precedence levels
					
					There are two ways of calculating precedence
						First Definition or Rolling Precedence (Current usage)
							The idea for this method is to select the converter that was defined first
								Since methods can be redefined at will, this leads to a rolling precedence calculation (precedence levels may change as the program executes)
							Problems
								Rearranging "require" statements may cause converters to be defined in different orders
									This can be slightly mitigated through "best practice" (define converters to and from two types in the same file)
									It could be possible to enforce this practice (though difficult)
								Decoupled types
									Two types are convertible to the other but neither require's the other
								Reassignment
									Assigining a converter to itself (even if the definition doesn't change) will rearrange the precedence

						First Declaration (Might end up using this)
							This is a conceptualization of "forward declarations"
							Could also offer more consistent behavior as compared to First Definition (no rolling precedence)

					Precedence resolution is the biggest reason why converters are not inherited in common type situations
						It's a computational minefield to select a converter, nevermind the problems involved in comparing precedence
							eg. a->c exists, where b < c and d->a exists, where b < d. What is the intended meaning of a + b if a->b and b->a don't exist?

		Common Ancestor
			This step is just a simple travel of the inheritance tree
				The idea is to find a type that both objects are sub-types of (and are therefore "implicitly" convertible to)
			This step always results in a usable type (as Nil is currently not implemented) due to the nature of the type heirarchy
				Guaranteed to return Object or a child type of Object
			Current implementation is to memoize this result for future lookup
				This also reuses the key I have to create to perform the Converter Search

Converters and Data Conversions (Need to rework this to provide a better explanation of Converters)
	Converters are nothing more than special functions
		Moreover converters are really only for the benefit of dust code (not for API development)
			The converter ensures that the data on the stack is interpreted in a certain way
				Also modifies the data if necessary
				The API needs to be able to access the data as-is in order for the converters to work properly
					Thusly the API only needs to know (and store) a small subset of types
			I can add functions/structures to the C++ API in order to emulate dust
				Moreover converters are little more than dust functions
					ie. They can be called by the API

	Converters can only be defined for types (they cannot be defined for individual tables/objects)