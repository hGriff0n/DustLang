## For final release, rely more on sentences and paragraphs

Dust Language Manual
version 0.1.7

## Versioning rules
## [milestone versioning].[minor versioning].[change versioning]
## milestones: main release, breaking changes, new features		|	Break or alteration of the existing systems
## minor: new library, new features, bug fixes, optimization	|	Improvement over the existing systems
## change: optimization, bug fixes, code/manual changes			|	Update or rewording of existing systems

## Start with a compiler, move to an interpreter when able

Table of Contents
	0. Overview
		0.1. Overview
		0.2. Definitions
	
	1. Code Organization
		1.1. Scope
			1.1.1. Definitions
			1.1.2. Lookup Rules
			1.1.3. Implementation
		1.2. Blocks
			1.2.1. Definitions
			1.2.2. Syntax
		1.3. Comments
			1.3.1. Definitions
			1.3.2. Syntax
		1.4. Booleans
			1.4.1. Definitions
			1.4.2. Usage
			1.4.3. Conversion
			1.4.4. Boolean Logic
			1.4.5. Boolean Operators
		1.5. Control Statements
			1.5.1. Definitions
			1.5.2. for loop
			1.5.3. if-then-else statements
			1.5.4. while loop
			1.5.5. do-while loop
			1.5.6. switch statement
			1.5.7. Order rearrange
		1.6. OOP ???
		
	2. Type System
	
	3. Variables
		3.1. Definitions
		3.2. Assignment
			3.2.1. Syntax
			3.2.2. Result
			3.2.3. Unassignment
			3.2.4. Multiple Assignment
		3.3. Constants
			3.3.1. Definitions
			3.3.2. Keyword
			3.3.3. Unassignment
			3.3.4. Multiple Assignment
		3.4. Value Access
			3.4.1. Definitions
			3.4.2. Process ???
			3.4.3. Result
		3.5. Implementation

	4. Tables
		4.1. Definitions
		4.2. Declaration
			4.2.1. Syntax
		4.3. Access
			4.3.1. Syntax
		4.4. Comprehension
			4.4.1. Syntax
			4.4.2.
			4.4.3. Implementation
		4.5. Ranges
			4.5.1. Definitions
			4.5.2. Syntax

	5. Functions
		5.1. Definitions
		5.2. Lambdas
			5.2.1. Declaration
			5.2.2. Closures
		5.3. Functions
			5.3.1. Declaration
			5.3.2. Overloading
		5.4. Calling
			5.4.1. Definitions
			5.4.2. Syntax
			5.4.3. Implementation
		5.5. Function Return
			5.5.1. Definitions
			5.5.2. Syntax
			5.5.3. Implementation
			5.5.4. Multiple Return
		5.6. Scoping
		5.7. Storage / First or second class

	6. Program Errors
		6.1. Definitions
		6.. Implementation

	7. Memory Model

	. Cross Language API				## Push backwards as needed
		.1. 

## BODY

0. Overview
	0.1. What is Dust?
		Dust aims to
		Dynamic, Strongly Typed

	0.2. Definitions
		Execution Space
		System-free
		System-reserved
		Pattern


1. Code Organization
	1.1. Scope
		1.1.1. Definitions
			A scope is any section of code that contains variable declarations or sub-scopes
			The values of all variables declared in a scope are accessible by any sub-scopes, provided the name has not been assigned in said scope
		1.1.2. Lookup Rules
			If a variable name is referenced in any scope, a nil value should be returned as last resort (but what if I assign to nil in the scope ???)
			The access should first be performed in the current scope and then in any parent scopes until a non-nil value or the global scope is reached
			Variables are automatically declared in the current scope (useful to have the possibility to go up a few scopes though) 
		1.1.3. Implementation
			It should eventually be possible to implement the lookup and variable presence rules entirely using tables and metamethods (another term ???)
			However for now, 

	1.2. Blocks
		1.2.1. Definitions
			A block is the primary way that scopes are entered and exited
			A block is a contiguous section of code that is indented to the same level (contiguous is not the right word here)
				## block1
					## block2
				## block 3 (should be block 1)
			Each block has its own scope
		1.2.2. Syntax
			A block is indicated by indentation to order of four spaces from its parent (default instead of prescribed ???)
		
	1.3. Comments
		1.3.1. Definitions
			
		1.3.2. Syntax
			Single line comments are started with '##' and ended with a newline
			Multiline comments are started with '###(#...)' and ended with a similar number of '#'
			## This style is only a temporary step. Possible /**, {#, (#, etc.

	1.4. Booleans  ## Needs Work
		1.4.1. Definitions
			A boolean only has two possible values, true or false
			Fliping a boolean will change its value to the other possible state (ie. true becomes false and vice versa)
		1.4.2. Usage
			Booleans signify whether a value/variable passes a certain criteria
			Booleans are expected by many system keywords and functions, particularly control statements
		1.4.3. Conversion
			The following values are implicitly converted to false when a boolean is needed
				[], nil, false, (0 ??? Doesn't feel right though)
			All other values are implicitly converted to true when a boolean is needed
		1.4.4. Boolean Logic
			The '!', not operator, flips the boolean value of the next expression
			The 'and' and 'or' operators perform exactly as their namesakes		## The keywords are subject to change
			## 'and' and 'or' return the right side arguments if the expression is true and false otherwise
			The presence of '<expr> and (true) or (false)' returns the true value if <expr> = true and the false value otherwise  ## Subject to change
		1.4.5. Boolean Operators
			'=' equal to
			'!=' not equal to
			'>' greater than		## and naturally >= and <=
			'<' less than
			## '<=>' omni sign, a <=> b gives 0 iff a = b, -1 iff a < b, and 1 iff a > b
		
	1.5. Control Statements
		1.5.1. Definitions
			
		1.5.2. for loop
			The pattern for a for loop is 'for <var> in <table> <block>'
			The for loop while execute once for every value in the table (at loop start or at loop end)
			For a general, from 1 to 10 loop, use ranges (ie. for <var> in <range> <expr>)
		1.5.3. if-then-else statements

		1.5.4. while loop
			The pattern for a while loop is 'while <expr> do <block>'
			The loop executes while the expression is true
			The expression is evaluated before the block
		1.5.5. do-while loop	## different name
			The pattern for a do-while loop is 'do while <expr> <block>'
			The loop executes while the expression is true
			The expression is evaluated after the block
		1.5.6. switch statement
			The pattern for a switch statement is 'switch <expr> (if <value> <block>...) otherwise <block>'
			The switch statement acts similar to a series of if statements
		1.5.7. Order Rearrange		## experimental (only consider implementing when the compiler/interpreter is stable/"healthy")
			The ordering of control patterns can be switched if a special syntax is used
			1, if x = 0						|	do 1 if x = 0
			print(y), for y in [1..10]		|	do print(y) for y in [1..10]
			print(x), while !x				|	do print(x) while !x
			print(x), do-while !x			|	do print(x) until x		## do while would have to be renamed in this statement
			switch x 1, if 0 7, otherwise	|	switch x do 1 if 0 otherwise 7

	1.6. OOP ???
		


2. Type System
	Currently the type system is dynamic (due to a lack of 'proper' syntax)
	It would be preferrable to have a duck or implict static or some mix of the two


3. Variables
	3.1. Definitions
		Variables are a collection of various strings that the interpreter has been instructed to treat as placeholders for data
		A variable must be a system-free string that does not begin with a number/literal marker or end with ':'(, except for table keys)

	3.2. Assignment
		3.2.1. Syntax
			The pattern for assignment is '<name>: <expr>' or '<name> :(=) <expr>'
		3.2.2. Result
			The result of a variable assignment is the value assigned to the variable
			This value is immediately discarded if it is not used in any immediate calculations
			Therefore variable assignment and creation are not location limited, but rather scope limited
			## Variable assignment is local by default (way to assign/reassign non-local variables in another scope ???)
		3.2.3. Unassignment (Do I want this behavior to be so casually possible ???)
			Assigning the value of nil with any variable cause the variable to "disappear"
			All variables, particularly unassigned variables, have a value of nil by default
		3.2.4. Multiple Assignment
			It is allowed for a comma seperated list of names to be on the left side of the assignment operator and a comma seperated list of expressions to be on the right
			In this case, the variables are assigned to the results of the expressions in a strict left to right manner
			If the variable list is larger than the expression list, then the left over variables are assigned 'nil'
			If the expression list is larger than the variable list, then the rightmost expressions are discarded (not evaluated)
			## This section needs to ensure that EXAMPLE 3.2.4. gives the expected results

	3.3. Constants
		3.3.1. Definitions
			The value of a constant variable cannot be modified through normal reassignment
			Have certain procedures/functions to modify constants ???
		3.3.2. Keyword
			The pattern for constants is 'let <assignment>'
			'let' is a system-reserved keyword
		3.3.3. Unassignment
			Constants cannot be reassigned to nil
		3.3.4. Multiple Assignment
			All variables to the right of the constant keyword in a multiple assignment list are constants
			Any variables to the left remain mutable

	3.4. Value Access (rename)
		3.4.1. Definitions
			A variable is unassigned if it does not have a value in any parent scope in relation to the current iteration enviroment
		3.4.2. Process (Refine and Rework once I've figured out the type system. I'm pretty sure I lose information in the current system)
			All unescaped system-free strings are automatically interpreted to be variable names
			If the next token in the iteration file is not ':=', then the variable is dereferenced to it's value
		3.4.3. Result
			The access should return the associated value of the nearest assigned variable (by scope lookup)
			In the case of an unassigned variable, the access returns nil

	3.5. Implementation
		Type, Value, Scope


4. Tables
	4.1. Definitions
		Set: Table with only numeric keys
		Array: Table with only a contiguous subset of integers as keys

	4.2. Declaration
		4.2.1. Syntax
			The pattern for tables is  '[(key:) value(,) ]'
			The presence of specific keys are optional
			If a key is not given, the default is the next integer
			The presence of a comma is required when seperating two values but is optional for the last value

	4.3. Access
		4.3.1. Syntax
			Tables can be accessed only through the '.' operator
			The pattern for table access is <table>.<key>
			The whole pattern is treated as the variable name in regards to assignment, access, etc.

	4.4. Comprehension
		4.4.1. Syntax
			The pattern for table comprehension is '[<lambda> | <arg> in <table>, (boolean filter)]'
			Multiple arguments from multiple tables and multiple filters are both allowed within a single comprehension
		4.4.2. 
		4.4.3. Implementation

	4.5. Ranges
		4.5.1. Definitions
		4.5.2. Syntax
			The pattern for ranges is '[<start>(, second)..(end)]'
		

5. Functions
	5.1. Definitions
	
	5.2. Lambdas or Anonymous Functions
		5.2.1. Declaration
			The pattern for lambdas is '\(args) -> (body)'
			If no body is provided, the lambda returns the arguments (identity function)
		5.2.2. Closures

	5.3. Functions
		5.3.1. Declaration
			The pattern for functions is 'def <name> (args)'	## or 'def <name> {args}'
			It is optional to surround args in '()/{}'
		5.3.2. Overloading
			## Not currently possible given the state of the type system

	5.4. Function Calling
		5.4.1. Definitions
		5.4.2. Syntax
			The pattern for function call is '<name>(<args>)'
			## The presence of ()/{} around the arguments is optional (if there are arguments ???) ## For now
		5.4.3. Type Checking
		5.4.4. Implementation

	5.5. Function Return
		5.5.1. Definitions
		5.5.2. Syntax
			By default, the last executed statement is the function's return value
			However, a 'return (expr)' will cause the function to immediately return the (expr)
			## Possibility for coroutines, resumable functions, etc.
		5.5.3. Implementation
			
		5.5.4. Multiple Return
			Much like multiple variable assignment, a comma seperated list of expressions will result in multiple values being returned at once

	5.6. Scoping
		Every function has its own scope
		However, currently the functions scope is only a subscope of the global state and not of the block where it was created

	5.7. Storage / First or second class


6. Error Handling
	6.1. Definitions
	6.2. "Raising"/"Throwing" errors
		6.2.1. Compile/Interpret-time errors
			Raised/Thrown by the compiler/interpreter on syntactical/semantical ambiguities/errors
		6.2.2. Runtime errors
			Raised/Thrown by the program/interpreter in case of unexpected/undefined behavior
			The syntax for raising/throwing errors is the '' keyword
	6.3. "Catching" errors
		6.3.1. Compile/Interpret-time errors
			Cannot be caught as the program can't run otherwise, since they are primarily syntax errors
			Semantic errors should probably be fixed if they are caught at this stage anyways
		6.3.2. Runtime errors
			## Idea 1
				Pattern of 'try <block> catch/handle <lambda>'
				If an error is "thrown" the catch block is run (type system depending)
				Note: 'try' has its own scope, but the block is typically not a "one-off" object
				Option: Enforce this distinction or migrate the try scope into the parent scope if the catch block is not run
			## Idea 2
				Keep the 'try' word as a block signifier that performs the second option from above
				Allow 'catch/handle' after every block to catch/handle errors from that block
		6.3.3. Uncaught errors
			The default behavior for handling errors is to log the error and then terminate
			The global state performs implicit error handling
			This behavior cannot be modified in pure dust code
			
	6.. Implementation

7. Memory Model


## DEPRECATED
. Data Structures
	

. Programming Styles
	Dust supports multiple programming styles
	.1. Object Oriented
		key words
	.2. Logic
		
	6.3. Symbolic
		key words: say ... in
	6.4. Procedural
	