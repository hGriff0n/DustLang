
## Function declaration syntax
	def abs x
	def abs(x)
	def abs{x}

## Function call syntax
	abs 4
	abs(4)/abs{4}		## Mirrors the chosen declaration syntax

## Lambda syntax (In order of current preference. Only 1 will be valid syntax)
	add2: \x -> x + 2		## haskell
	add2: (x) -> x + 2		## java
	add2: {x} -> x + 2		## java/C++ derived

	What does '\ -> x' represent ???
		Function with no arguments that returns the variable x (what is x ???)
		
Function Return Syntax
	A return expression takes the place of the function in whatever instance the function was called from
		In the case of lazy evaluation the variable value would be replace by the return statement
	Implicit return statement
		The value of the last executed statement is the return value of the function
	Explicit return statement
		The 'return' keyword returns the the following expression
	Multiple Return
		A return expression can be a comma seperated list of values (as in multiple variable assignment)
		This is the mechanism by which multiple values can be returned from a function
		
Type Checking
	Function arguments are implicitly constant (ie. they can't be modified)
	Errors are only thrown when a type-undefined system operation is performed	## For now

	## For fully defined
	Implicit type checking (Duck Typing)
	Explicit type checking

	## explicit type checking ???
	def abs(x <- Number)		## The same syntax as Static Typing
		return x, if x >= 0
		return -x, if x < 0
		## throw error
	
Function Overloading
	## Currently function overloading is impossible

Type Functions	## How will this work
	## eg. [].size()			This might be problematic in the case of overloading
	I'm thinking a solution of the forms x.f(y) = f(x, y) (See C++17 proposal N4474) and everything is an object

Closures

Currying
	add2: \x -> 2 +		## Equivalent to above examples
	add2: \x => 2 +		## Special currying syntax ???

Pattern Matching
	def add([x, y,])		## would this only catch a table with size of 2 or 
		x + y

	add [3, 5]		=> 8
	add 3, 5		=> Error: Method 'add' undefined for arguments of type 'Int, Int'	## More consistent reasoning, but might be advantageous to allow otherwise
	add [3], [5]	=> Error: Method 'add' undefined for arguments of type 'Table, Table'
	add [[3], [5]]	=> [3, 5] ## Depends on whether '+' can add two tables
	add [3, 5, 8]	=> 8
	add 3, [5]		=> Error: Method 'add' undefined for arguments of type 'Int, Table' ## Should Int + Table = Table or Int ++ Table = Table

	## As opposed to ...
	def add(x, y)
		x + y

	add [3, 5]		=> Error: method 'add' undefined for arguments of type 'Table'
	add 3, 5		=> 8
	add [3], [5]	=> [3, 5]
	add [[3], [5]]	=> Error: method 'add' undefined for arguments of type 'Table'
	add [3, 5, 8]	=> Error: method 'add' undefined for arguments of type 'Table'
	add 3, [5]		=> [3, 5]

	## What about pure "haskell" pattern matching ???
	def add(4, 2)					## I feel like this would be costly to implement
		42							## The syntax is spot on though

	## assuming the previous two definitions are valid
	add [4, 2]		=> 8
	add [4], 2		=> [3, 5]
	add 4, 2		=> 42			## The above pattern matched function is called
	add 2, 4		=> 6

Functions as objects (ala Scala) ???

Named arguments