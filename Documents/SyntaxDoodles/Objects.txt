

Type Declaration
	type <type> <table>			## Typename may have to be capitalized (currently undecided)

	type Foo [			## defines a new type with member variables
		attr: 5
	]

Type Methods
	Methods can be declared either as lambdas inside the type declaration or as functions outside (prepend with type name, much like tables)
		Distinction between "static" and "instance" methods (possibilities)
			Have all inline methods as static and all outside as instance
			Have special syntax/keywords to specify (similar to Objective-C)
			Have the first argument to be implicitly the object (similar to Lua)

	type Foo [
		attr: 5,
		new: \x -> attr: x
	]

	How to define static variables ???
		What's the point of static methods if static variables don't exist
			You can always have static methods be free functions anyways

		Scoping syntax
			You can use the same syntax for scope lookup (though some syntaxes don't work for this)

		Special static symbol (@, $, ...)
			Append the symbol to the field name
			Doesn't work well outside of the type table (inline definitions)
				Could cause problems defining static methods outside of the type table

		Provide a special "static" keyword that redirects to the type table
			Could also index the type table directly (redifinitions, etc.)

	## implicit "foo" parameter that these work on
	def Foo@new(x)		def @Foo.new(x)		def Foo?new(x)		defs Foo.new(x)		def Foo.new(foo, x)		## have a way to implicitly pass self as the first arg
		count:+ 1			count:+ 1			count:+ 1			count:+ 1			count:+ 1

	def Foo.$new(x)		def Foo.@new(x)
		count:+ 1			count:+ 1

	def Foo.new(x)		def Foo.set(x)
		Foo.count:+ 1		attr: x

Way to implement '__newindex'-esque behavior
	The basic idea is to allow foo.decrement(3) to provide some valid behavior
		Possibly even be a way to extend type definitions
			This would basically take the place of message passing
			See ruby for a more in depth view of this phenomenon

	Since types are basically tables (and may even be implemented as tables)
		It could come down to defining '__newindex' on the type
			I could also have some other field name that basically redirects to '__newindex' (but more inline with "type" thinking)


## I'm leaning towards deprecating this section (once I've figured out how to implement currying)
Message Passing		## I don't quite know what this is, but this seems like an nice syntax
	x: new Foo(3)			## should probably rearrange to Foo.new or Foo(), but many are familiar with this syntax
							## This could possibly help with implementing currying
							## ie. \i,j -> * turns into {i op* j} or something like that (would it be possible to have something like {(nil) op* i j})

	x.increment(2)			## Standard syntax
	{x increment 2}			## In Object-C, this would read [x increment: 2]
	(x increment 2)
	($x increment 2)		## would I need the parenthesis here
	(x increment <- 2)
	(x <- increment 2)
	(x increment | 2)
	(x | increment 2)

	General syntax appears to be
		<signifier><variable> <method> "<args>" " " <signifer>
			ie. ( x increment 2 )
		(<variable> <signifier> <method> "<args>" ", ")

	Questions
		How should message passing nil/nothing be defined (ie. what does { increment x 2} produce)
			Wouldn't the message passing just translate to @<variable>.<method>(<args>) ??
			So then passing nothing would directly translate to @.<method>(<args>)	(ie. calls the method as defined in the scope)


Dust OOP
	Interface of supported functions
		I don't know if this is going to be feasible to implement
			Maybe with Message Passing, otherwise not without the Type Functions proposal
		interface Foo x
			has_method? x <method> ...

	Combination of Interface and Implementation
		type Foo [ x: 3 ]

Inheritence syntax
	<type> ++ <type_list>
		This does mean that dust supports multiple inheritance (I feel its consistent with the internal model, I also come from C++)

	type Bar [
		width: 3,
		height: 4
	] ++ Foo

	Currently the ++ is a special syntax for types
		Could I make so that ++ performs some function on tables in general (depends on the implementation of type inheritance)
			Setting up metatables?
		Otherwise I'll seriously consider using + instead
			I don't think it'd quite as succintly express the same semantics however


Interfaces (If I ever implement them)
	Interfaces check if a given object has a series of functions defined for its type either as members or possibly free functions
		Don't know about the feasibility (free functions/etc.)

	What's the use ???
		Duck Type checking at the function call line
			But this kinda defeats the purpose of duck typing

	Taking advantage of the "logic" syntax in dust(deprecated)'
		interface Printable x					## ie. x is a Printable iff x has a print method
			has_method? x, print
	Alternate
		interface Printable x					## this is a skin of a function call
			!(nil ^ [ x.print ])				## if any of the methods are undefined for x (ie. nil) then the interface "test" fails
	Concept system ???


Extensible objects
	Can member functions be added to an object after declaration and definition (can objects accrue methods as the program executes)
		I feel like I should allow this to be a possibility (it's certainly in the language's dna)
		But at the same time there should be a way to restrict modifications (even from API functions)
			This restriction would be really useful throughout the entire language


Everything's an object (ala Ruby) ???
	Variables, even of "primitive" types have access to various type function (through indexing)
		This just provides a semantic meaning to "x.add(3)" and "3.add(x)"
		Small question about differentiating between inplace assignment (I don't think this would be valid, given the function restrictions)

Convertible Types
	Way to define the behavior of "" + 5 = "5"				## Int is automatically converted to a string

	System defined convertability
		Probably the simpler option
			May even be the only option for some types (such as Int/String)
		But not as extensible

	User defined convertability
		def <type>.<type>()
			ie. Int.String() defines the conversion from Int to String
		These functions would be hidden from the interpreter when running overload dispatch (currently)
			That provides an interesting point into whether I should evaluate arguments
				If I don't evaluate them, how am I supposed to know their type?