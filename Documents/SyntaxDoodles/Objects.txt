type Foo [			## defines a new type with member variables
	attr: 5			## note the similarity to table syntax
]					## that's because types are basically preset tables (needs more explanation, how do the presets work)

def Foo.new(x)		## define the function for creating new "Foo"s
	attr: x			## implicit "self"/"this"

def Foo.tostring()	## define the conversion to string (this how I do it)
	attr

def Foo.increment(y)
	attr :+ y

Message Passing		## I don't quite know what this is, but this seems like an nice syntax
	x: new Foo(3)
	x increment, 3		## equivalent to x.increment 3
	increment x, 3		## since new Foo calls Foo.new ???


## type, object, or class for declaration keyword
	## changing it from type would allow me to implement the logic section from dust_test(deprecated)
	## that "type" syntax would dovetail rather nicely with the idea to have Java-like interfaces / C++ concepts
	## what about having "haskell-like" types as well (maybe have type and interface/concept keywords)
	## type describes the implementation/ordering of the data, interface/concept the functions ???


## possibilities for type inheritance
type Bar inherits Foo [
	width: 3,
	height: 4	## should height: width (height equals weight by default) be possible ??? (global question about table initialization order)
]

-or-

type Bar [
	width: 3,
	height: 4
] + Foo			## inherits Foo members & methods (retroactive ???)
				## fairly easy to handle access rules, if name's not defined in Bar, call Foo.name(this, ...)

-or-

type Bar [
	width: 3,
	height: 4
] ++ Foo		## Have '++' be a special syntax ??? (I don't like the idea of special syntax, but the '++' feels better)

## Way to make Java's interfaces possible ???