

Type Declaration
	type <type> <table>			## Typename may have to be capitalized (currently undecided)

	type Foo [			## defines a new type with member variables
		attr: 5
	]

Type Methods
	Methods can be declared either as lambdas inside the type declaration or as functions outside (prepend with type name, much like tables)
		Distinction between "static" and "instance" methods (possibilities)
			Have all functions defined as methods to be instance
			Have all inline methods as static and all outside as instance
			Have special syntax/keywords to specify (similar to Objective-C)
			Have the first argument to be implicitly the object (similar to Lua)

	def Foo.new(foo, x)		## define the function for creating new "Foo"s
		foo.attr: x

	def Foo.new(x)
		attr: x				## implicit self

	def Foo.increment(foo, y)
		foo.attr :+ y

Way to implement '__newindex' behavior
	see "ruby"

	## I'm currently leaning towards deprecating this section (once I've figured out how to implement currying)
Message Passing		## I don't quite know what this is, but this seems like an nice syntax
	x: new Foo(3)			## should probably rearrange to Foo.new or Foo(), but many are familiar with this syntax
							## This could possibly help with implementing currying
							## ie. \i,j -> * turns into {i op* j} or something like that (would it be possible to have something like {(nil) op* i j})

	x.increment(2)			## Standard syntax
	{x increment 2}			## In Object-C, this would read [x increment: 2]
	(x increment 2)
	($x increment 2)		## would I need the parenthesis here
	(x increment <- 2)
	(x <- increment 2)
	(x increment | 2)
	(x | increment 2)

	General syntax appears to be
		<signifier><variable> <method> "<args>" " " <signifer>
			ie. ( x increment 2 )
		(<variable> <signifier> <method> "<args>" ", ")

	Questions
		How should message passing nil/nothing be defined (ie. what does { increment x 2} produce)
			Wouldn't the message passing just translate to @<variable>.<method>(<args>) ??
			So then passing nothing would directly translate to @.<method>(<args>)	(ie. calls the method as defined in the scope)

Dust OOP
	Interface of supported functions
		I don't know if this is going to be feasible to implement
			Maybe with Message Passing, otherwise not without the Type Functions proposal
		interface Foo x
			has_method? x <method> ...

	Combination of Interface and Implementation
		type Foo [ x: 3 ]

Inheritence syntax
	<type> ++ <type_list>
		This does mean that dust supports multiple inheritance (I feel its consistent with the internal model however, I also come from C++)

	type Bar [
		width: 3,
		height: 4
	] ++ Foo

	Currently the ++ is a special syntax for types
		Could I make so that ++ performs some function on tables in general (depends on the implementation of type inheritance)
			Setting up metatables?
		Otherwise I'll seriously consider using + instead
			I don't think it'd quite as succintly express the same semantics however

Interfaces (If I ever implement them)
	Interfaces check if a given object has a series of functions defined for its type either as members or possibly free functions
		Don't know about the feasibility (free functions/etc.)

	What's the use ???
		Duck Type checking at the function call line
			But this kinda defeats the purpose of duck typing

	Taking advantage of the "logic" syntax in dust(deprecated)'
		interface Printable x					## ie. x is a Printable iff x has a print method
			has_method? x, print
	Alternate
		interface Printable x					## this is a skin of a function call
			!(nil ^ [ x.print ])				## if any of the methods are undefined for x (ie. nil) then the interface "test" fails
	Concept system ???

Extensible objects
	Can member functions be added to an object after declaration and definition (can objects accrue methods as the program executes)

Everything's an object (ala Ruby) ???

Convertible Types
	"" + 5 = "5"		## Int is automatically converted to a string
	System defined convertability
		Probably the simpler option
	User defined convertability (I like this more)
		def <type>.<type>()
			ie. Int.String() defines the conversion from Int to String