if-else-elseif 
	Testing the syntax for if-else-elseif branches in multiline, oneline, and noline variants
		Testing "no keyword", "if - then", "do-block"

	def twoLineIf(x)
		if x < 50
			print("x is smaller than 50")
			return x * 2
		elseif x < 100
			print("x is smaller than 100")
			return x
		else
			print("x is a big number")
			return x / 2

	def twoLineIf(x)
		if x < 50 then
			print("x is smaller than 50")
			return x * 2
		elseif x < 100 then
			print("x is smaller than 100")
			return x
		else
			print("x is a big number")
			return x / 2
			
	def twoLineIf(x)
		if x < 50 do
			print("x is smaller than 50")
			return x * 2
		elseif x < 100 do
			print("x is smaller than 100")
			return x
		else do
			print("x is a big number")
			return x / 2
		
			
	def oneLineIf(x)
		if x < 50
			print("x is smaller than 50") and x * 2
		elseif x < 100
			print("x is smaller than 100") and x
		else
			print("x is a big number") and x / 2
			
	def oneLineIf(x)
		if x < 50 then
			print("x is smaller than 50") and x * 2
		elseif x < 100 then
			print("x is smaller than 100") and x
		else
			print("x is a big number") and x / 2
			
	def oneLineIf(x)
		if x < 50 do
			print("x is smaller than 50") and x * 2
		elseif x < 100 do
			print("x is smaller than 100") and x
		else do
			print("x is a big number") and x / 2


	def noLineIf(x)
		if x < 50 print("x is smaller than 50")
		elseif x < 100 print("x is smaller than 100")
		else print("x is a big number")
		
	def noLineIf(x)
		if x < 50 then print("x is smaller than 50")
		elseif x < 100 then print("x is smaller than 100")
		else print("x is a big number")
		
	def noLineIf(x)
		if x < 50 do print("x is smaller than 50")
		elseif x < 100 do print("x is smaller than 100")
		else do print("x is a big number")

	def noLineIf(x)
		if (x < 50) print("x is smaller than 50")
		elseif (x < 100) print("x is smaller than 100")
		else print("x is a big number")

Scoping
	To assign a variable from an enclosing scope		## currently access will return the first non-nil value
		@x: 3
		$x: 3
	@x refers to the variable 'x' from the enclosing scope
		Or @x refers to the variable 'x' in the nearest scope where x is defined
		@@x refers to the enclosing scope of the enclosing scope
			Basically "stacking" enclosing lookups
		Behavior if the current scope is the global scope (ie. there is no enclosing scope)
			1) Throw an error
			2) Silently fail (ie. @x = x)
		Could I have special syntax for "searching" lookup ??
			ie. @..x will return the value of x in nearest scoped that x is defined in (this is unnecessary if the second definition is taken)

"do-block" syntax (possibility?)
	do
		x: 5
		print(x)		## 5
	print(x)			## nil

	This is a "nice" syntax for creating blocks of code without the presence of control structures et al

Statement seperator
	Should I have a ';' like character to seperate statements in a single line ???