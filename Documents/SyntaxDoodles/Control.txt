Execution Structures
	if-else-elseif
		if <expr> <block>
		'elseif <expr> <block>'*
		'else <block>'?

		This setup could possibly allow multiple different syntaxes to be used
			The 'do' syntax for blocks is of particular note here

		if x < 50
			print("x is smaller than 50")

		if x > 20 do										## This (possibly) means that "do" is a keyword similar to "then"
			x:- 10											## This is because of the possible "do-block" syntax

		if (x > 25)											## You can optionally wrap the boolean expression in parentheses (might not have to directly implement this)
			print("x is greater than 35")

	Currently no switch statement in dust
		I don't know what the exact benefit of a 'switch' is

	Ternary Statement
		<expr> and <expr> or <expr>
			I'm currently going to "overload" and/or to "return" <expr> in their individual cases
				Wrapping the whole structure might be a bit complicated
		It could be possible to write one line if-else's using the control expressions idea

Looping Structures
	for
		for <var> in <table> <block>
		Executes the given block for each entry in the table
			Each entry is stored in the var for use in the block

		Pure for-each style
			Unlike in Lua, there is no direct syntax for increment loops
			It is possible to simulate the syntax using ranges

		Generator idiom support ??
			A function that acts like an iterator (ie. can be used in a for loop)
				There's two ways of doing this
					Have a yield keyword (ala Python/Lua)
					Have re-entrant functions (using return values as arguments gives the next return values in the series)
				You could even remove the other type support and use only this (maybe with some sugar)
			What does this provide
				Provides a degree of concurrency/laziness
				Could also have <var_list> instead of just <var>
			Something to consider as the language develops (ie. later)

	while
		while <expr> <block>
		Executes the given block while the expression evaluates to true

	until
		until <expr> <block>
		Executes the given block until the expression evaluates to true
		Guaranteed to execute at least once
			Largely to differentiate it from while loops

Control Structures as Expressions
	Extends the rules regarding the implicit return statement to control strucutres
		Ie. the value of the last executed statement is the value of the structure
			This does not include the bound/boolean checks in loops
		You really have to wrap the structure in parentheses to get any use out of it (especially for loops)
			Otherwise with scoping, any "additional" stuff is either part of the loop or on a different line (ie. syntax error)

	Table.sum: \l, sum: 0 -> for x in l .sum:+ x		## sum is implicitly returned here
	-versus-
	Table.sum: \l, sum: 0 ->
		for x in l .sum:+ x
		return sum
	-versus-
	Table.sum: \t -> t.reduce \x, s -> x + s

	x: if y = 3 4 else 2
	-versus-
	x: y = 3 and 4 or 2

	This also means you can "assign" loops
		x: for z in [1..10] z * 2						## equivalent to x: 10 * 2
		This is really only useful when wrapped in parentheses

Shortcircuiting evaluation
	Returning a value from a control structure without evaluating all expressions
		Shortcircuits the implicit return rules of control structures/functions
			Causes the following expression list to be evaluated and then skips all following evaluation (thereby causing the list to be the "last evaluated expression")

		"for x in [1..5] if x = 3 return x" is an example of shortcircuiting the for loop
		Currently there are two different semantics (and syntaxes) for doing so
			However a third may be added in later (depending on resumable functions)
			All syntaxes follow the same formula of "<keyword> <expr_list>"

	Hard exit	- return
		The main use for return is within functions (although it is allowable to use within the default process)
		Hard exit causes the program to return to the "call point" (or exits the program if in the default process)
			The "call point" is the section where the function was called

	Soft exit	 - break
		Soft exit causes the program to go "up" one level of scoping				## see break/continue in other languages
			Similar semantically to hard exit but with a more limited focus (and a more general use case)
			May also have no meaning when used in the default process (ie. break 5)

		do
			x: (for x in [1..5] if x = 3 break x)
		print(x)										## outputs '3' (wouldn't output if return was used)

	Resumable exit - yield (if resumable functions are implemented)
		Similar semantics to Python and Lua

Boolean Expressions and Operations
	true/false
		[] and nil are implicitly convertible to false (0 might be included)
		All other values are convertible to true

	and/or	(ie. <expr> and|or <expr>)
		Both keywords are short-circuited
		The value of the construct is the value of the last evaluated expression
			This means that <expr1> and <expr2> =
				expr1 if expr1 = false
				expr2 otherwise

	! (not operator)
		maps true to false and false to true
		_op!: \b -> b = true and false or true

	=, <, <=, >=, >, !=, <=>
		Only = and < technically require a definition
			However, at the minimum I might also define >		## floating point considerations
		Comparator function (ala '<=>')
			-1 if a < b, 0 if a = b, 1 if a > b, and nil otherwise
			I might still need to system define '=' for this
		Metamethod defs (this is still compatible with comparator)

Structure reordering
	Would it be possible to reverse the ordering of pieces within a control structure (ala Ruby)
		Something on the order of "<block> if <expr>"

	My current idea is to use ','
		<block>, if <expr>

Scopes
	Module Scoping (something to consider later)
		Way to define a local "global" scope (especially for use in modules)

Variable Scope Lookup					(ie. How to determine which variable is being referenced accross scopes)
	The first method is to search for a scope where the variable is defined
		If the current scope doesn't have 'x' defined than lookup goes to the parent scope
			Note, that the current "nil = deletion" logic could cause some problems						## Are they problems or not
			Note that if the current scope is the global scope, than lookup will "fail" (nil or error)
				I could also give the ability to put a hard limit on the number of recursions before the lookup "gives up"
		If the current scope does have 'x' defined than the lookup stage is over

	However in variable assignment, this lookup is not performed				## Assignment is local by default
		To force a lookup when assigning, you can prepend the variable with a '.'
			Semantically speaking, this also forces the lookup to begin up a level
		The '.' also works on variable access in the same way (ie. force up a level)
		The effects of the '.' are local to the applied variable
			So in ".x, y: 3, 5" only 'x' is subject to the lookup rules

	Question regarding stacking lookups
		x: 3
			x: 5
				..x: 7				## These two lines attempt to define the x two scopes prior
					.(.x): 9
						..y: 7		## y is declared in the global scope (or will the second scope op do otherwise)

		I could say this is bad and refuse to support it

"do-block" syntax (possibility?)
	do
		x: 5
		print(x)		## 5
	print(x)			## nil

	I could go halfway this
		Reserve "do" as a keyword but have it actually do nothing
		The capability to signify blocks can be easily added in later (especially since blocks are indented)

Statement seperator
	Allow multiple, independent statements to coincide on one line
	x: 5
	print x

	Option ()			## Lisp-style syntax
		Generalize the rules so that every expression results in a value
			These intermediate values are often discarded
			This also would have an affect on function arguments

		(x: 5) (print x)
	
Statement scoping
	Not currently supported in Dust
		No "good" syntax
		No appreciable need