Table Variables
	Style
		[(key:) value, ...]
	SubTypes
		Arrays
			Table with only a contiguous subset of integers as keys 
			Default mode of variable assignment
				ie. if a key is not specified it is assumed to be the next available integer
		Sets
			Table with only numeric keys

## Tables signified with '[]'
## Values in table declarations are seperated with commas
## The last value in the declaration may have a comma after it (see r)
r: [1, 2, 3, 4, 5,]
l: [2, 4, 6, 8, 10]
w: [[1, top: 2], 3, 4, 5]
g: [hello: 3, 4, 2, bye: 1]

## Tables are, by default, 1-indexed
So in the above example, r.1 = 1 and not 2

## Why
Well, 0 based indexing is really only natural to programmers with experience in C and C like languages
The original idea was for this language to be interpreted, so performance was not a particular concern
Table iteration is accomplished with 'for all' type loops, so specific indices are not important
Tables can contain keys of any value, so 1 based indexing is only an assumption for standard functions/libraries
This behavior, moreover, can "possibly" be modified in-language by redefining global functions/metamethods

## Table access is performed through '.'
## Table keys circumvent the global rule for variable names (currently)
	## This was to allow r.1 to access the first element (r[1]) but I'm not sure if that's desirable or not
## The dot syntax is only applicable for string keys (easy implementation and removes ambiguities ie. r.1 = r[1] or r["1"])
## -OR- Have numeric strings automatically converted to ints when used to index (reduce the number of keys but how often is this used anyways)
	## It should be an easy fix regardless, especially if I implement the key restriction thing below
r.1		## r[1]
g.hello
w.1.top := 3
w.1.top: 3

## It should be possible to restrict the type of keys/values that a table will support
## This will allow globals to be "table" values as in Lua and the language spec to be consistent
## But there still are some problems. (Do I want 0 to always be 0 ???)

Set Comprehension Syntax (In order of current preference. Only 1 will be valid syntax)
mult: [\x,y -> * | x in l, y in r, true]		## custom (currying syntax notwithstanding)
mult: [\x,y -> * | in l, in r, true]			## possible alternate (the 'x in' part's not really necessary if I have arguments to the lambda)
mult: [\ -> x*y | x in l, y in r, true]			## possilbe elision (if captures are implemented) (then what would [\x | x in l] become ???)
mult: [x * y | x in l, y in r, true]			## haskell derived (this could be possible with some syntactical sugar)
mult: [x * y for x in l, y in r if true]		## python


Table/Set operations
	Currently it is valid to perform an operation of Table + Int. In these cases the non-table type is
		Implicitly converted to a Table whose sole element is the non-table value.
	Currently they are not all that well defined either

	## From viewing the Stanford Compiler course. A + B reads "union of A and B" in regexs

	Addition (+)								## Appends the elements from one table to the other
		I don't think this is entirely possible to implement in Dust (aside from calling a function)
	Subtraction (-)								## Removes all elements of one table from the other
		Need to decide whether [2,2] - [2] should give [2] or []
		Or in other words, should ([2] + [2]) - [2] = [2]		(since [2] + [2] = [2,2])
		[2] + ([2] - [2]) will be [2] no matter how op- is defined for table
		\l, r -> [\x | x in l, !r.has(x)]			## Technically this is wrong.	eg. [2, 2] - [2] will give [] but should give [2] (or should it (see python) ???)
	Union (&)									## Takes the union of two tables
		\l,r -> l + (r - l)						## I think [2] & [2] = [2]
	Intersection (^)							## Takes the intersection of two tables
		\l,r -> l - (l - r)
		## \l,r -> [\x | x in l, r.has(x)].flatten

Set Ranges
	[1..10] is equivalent to [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]		## Range syntax: [<start>(,second)..(stop)(, lambda)]
	[1,3..10] is equivalent to [1, 3, 5, 7, 9]						## Custom range increments can be inferred by stating the second value
	[1..] is equivalent to [1, 2, 3, 4, 5, ....]					## Ranges can be infinite (iff lazy evaluation is implemented)
	[10..1] is equivalent to [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]		## Sign increments can be inferred automatically
	[1..25, \x -> x^2] gives [1, 4, 9, 16, 25]						## Algorithmic steps can be specified by a function (that does what ???)
	## what about open interval ranges? ie. [1..10) = [1, 2, 3, 4, 5, 6, 7, 8, 9]

Pattern Matching (Or should this go into functions ???)
	def add([x, y])
		x + y

	Takes a table as an argument and associates the items at index 1 with 'x'
	And index 2 with 'y', etc. If the pattern has more arguments than the passed table
	The extra arguments are assigned nil. If the table has more items than the pattern arguments
	The leftover items are collected in the last variable. Note, x + y + _ = the passed table

	Could this be sugar for ???
		def add(t <- Table)
			(\x,y -> x + y)(*t)		## *t = "explode" the table

	What about collecting leftovers in a variable ???
		def add([x, *y])		## explicit
			x + y <- Table and add(y) or y

		def add([x, y])			## implicit
			x + y <- Table and add(y) or y


Metamethods (another term ???)
	Metamethods are simply specific functions that the compiler/interpreter expects to be defined
	For specific types in order to perform certain behaviors. For example, table.key will call the
	Tables's '__index' metamethod to perform the actual behavior. This allows program performance
	To be easily and infinitely modifiable, much like in Lua. It may be beneficial to also include
	Several functions that themselves modify metamethods, such as the '__memoize' function below.

	factorial: [						## This memorization table for the computation of factorials
		0: 1,							## However through metamethods, it also doubles as the function itself
		__memoize: \x ->				## This defines the memoization function
			if x < 0, return nil		## But it also modifies the table (See NeatTricks.txt)
			x *	factorial[x - 1],
		__call: \x -> factorial[x]		## Validates 'factorial(4)' syntax. Only syntactical sugar in the long run
	]

	Should metamethods tend to be prefixed with something, should they all be prefixed with something, or should it be entirely optional
		__call, __memoize, __index, __newindex
		op+, op-, op&, op^, op<, op>, op= etc.		## <=: \x,y -> x < y or x = y

	How to refer to the table			## can this be generalized to all table functions
		self/this keyword				## could this be implicit when accessing table fields

Interaction between tables and constant-ness (Metamethods and 'let' syntax)
	To have a table where values/fields can be added but not changed (see NeatTricks memoize example)
		Use 'let' fields								## Generalization of the constant declarization rules (they're not exactly defined though)
			const_table: [ let x: 5	]

		For a more generalized (ie. table-wide) behavior
			__newindex: \x,y -> y and (let self[x]: y)		## wouldn't this call __newindex ???

		Or disable reassignment
			__index: \x -> self[x]						## const_table.x: 3 is const_table.__index("x", 3)

		Can possibly extract some details of the specifics to some outside function/factory
		Or to a table "bit-flag" such as '__allowReassign' that can enable the above methods (needs a better name though)

	To have a fixed table with mutable values (ie. values can be changed but not added)
		Disable assignment by redefining the __newindex metamethod
			fixed_table: [
				__newindex: \ -> nil					## fixed by proxy
				__newindex: noAssign					## __newindex: nil (ie. is nil(x, y) valid syntax/semantics ???)
			]

		Can possibly extract some details of the specifics to some outside function/factory
		Or to a table "bit-flag" such as '__allowAssign' that can enable the above methods (needs a better name though)

	To have a fixed table with constant values (ie. combine the above two "problems")
		Use 'let' syntax (declare the table with let)	## This solution could also solve P1 behavior (most languages treat this as such)
			let immutable_table: []						## I feel that this option is simpler and more consistent however (see Java classes)
														## ie. modifying a field of a const table feels duplicitous
		Disable reassignment and assignment by redefining __index and __newindex
			This is a combination to the above "solutions" 

	Note: I have to define let syntax as a solution to one of the problems,
		Even though I don't need such syntax for the tables themselves.
		This is to ensure correctness and viability of the language, namely
		The constant declaration syntax (This problem comes around to affect
		The solutions created above). The question is, What is the semantic
		Meaning of 'let x: []'?. This question is important because it is
		A common and possibly useful construct of the language syntax, as
		Evident in P1 S1. Therefore if 'let x: []' is to not have a valid 
		Meaning, it must entail the enforcement of a confusing and arbitrary rule.
		By giving a semantical meaning to the construct, it maintains programmer
		Freedom and possibly eases the implementation of future features/details.

What about multi-dimensional tables (ie. matrices) ??? [i,j] vs. [i][j]
	## This would allow the "memoization" trick to be trully useful without any extra classes/trouble
	Should 'battleship[c,6]' be acceptable or should 'battleship[c][6]' be the only allowed syntax
	The first style dovetails nicely with the ability to easily implement memorization tables as
		matrices are often used in "memorization" problems, especially if types can't be combined easily (c,6 => c6)
		Otherwise something like 'battleship[tile(c, 6)]' would have to be used in order to gain the benefits (I might be able to say otherwise)
	See LCStests.txt for Longest Common Subsequence implemented in [i][j] and [i,j] syntax

	The code is simpler and more natural in [i,j] syntax. The expansion also requires less calls (although this can be optimized)
	However, [i][j] syntax does not require any extra work in the compiler/interpreter to allow the "sugar" that is [i, j]
	Nor does it require tables (the easiest implementation of [i,j]) to be keys which simplifies lookup/removal (should [1,2] = [i,2] if i=1. in lua this is false)

What about defining multiple lambdas inside a table if one or more are multi-lined
	Try to make it so that a multi-lined lambda only needs the default table seperator to
		be defined inline. Consider alternate syntax or restrictions if it is no possible

	test: [
		hello: \x ->
			if x <- String
				print("Hello " + x),				## hopefully this comma (and the indentation difference) is enough
		goodbye: \ -> print "Goodbye",
		op+: \x -> "Your name is " + x
	]

Table functions
	size(table)				## or go Lua and have a size operator (op#)
	pair(table, ...)		## creates a table of tables so that pair(t, tb).i = [t.i, tb.i] (zip?)
	entries(table)			## similar to python.enumerate. maybe change the name
	flatten/smooth(table)	## Removes nesting in a list

	def type([]).reduce(t <- Table, fn <- Function, sum)
		if !sum sum, t: fst(t), tail(t)						## but isn't my current rules that the arguments are constant
		for x in t sum: fn(x, sum)
		sum													## is this line necessary or would the function return sum regardless??

	type([]).has: \t,v -> t ^ v
	type([]).map: \t,fn -> [\x -> fn(x) | x in t]			## currently type([]) returns a string
	type([]).sum: \t -> t.reduce(\x, s -> x + s)
	type([]).entries: \t -> t.pair(t.keys, t.values)		## Might change the naming. Also, t.1 gives the key as opposed to t.key 

Translating tables into collection of objects and vice versa
	I like *t for doing this, however that could clashe with the multiplying operator, op*

	def quick(sel)
		sel <- Table and quick(*sel) or sel		## type(sel) = "table"
	def quick(sel, *list)
		mid: [sel]
		high: low: []
		for item in list
			switch item <=> sel			## works similar to Java's compareTo
				high + item, if 1
				low + item, if -1
				mid + item, otherwise
		[quick(low), mid, quick(high)].flatten()

	def quick([sel, *list])				## overloading not needed with pattern matching (only accepts tables)
		if !list return sel
		mid: [sel]						## how about 'mid, high: [sel], low: []'
		high: low: []					## the question is about evalutation order (does low: get evaluated before high:)
		for item in list
			switch item <=> sel			## the omni-sign is not valid syntax yet
				high + item, if 1
				low + item, if -1
				mid + item
		[quick(low), mid, quick(high)].flatten()

Have a syntax/ability to perform python-like slices???
	Python code: arr[:n]	get the first n items
				 arr[i:i+n] get the first n items starting at i
				 arr[i:n]	get the subarray from i to n (not actually python syntax)

	Could arr[i,j] be an slice (with a __slice metamethod) ???

## repl.it