Variable ssignment
	Style
		x: 5
	General feel
		Clean and concise assignment Syntax
		Intuitive syntax for non-array table keys
		Inconsistent feel when combined with 'let' and tables
	Consistency
		':' means always means assignment
		Assignment always entails ':'
	Flexibility
		Allows simple use of '=' for equality
	Cons
		No "good" way to have '+=' type operators
	Alternatives
		x = 5
		x := 5
		x <- 5
		5 -> x

let x: [4, y: 3]
z: [2, 3]
y: (x: 5) + 4			## Error: Reassignment of constant variable 'x'
y: (z: 5) + 4			## Valid: Variable 'z' is not marked constant
y: \ -> (x: 5) + 4			## Valid: Variable 'x' is in scope 'y' (lambda function)		Syntax will change

x, y: 3, 4				## Equivalent x: 3; y: 4


## EXAMPLE 3.2.4.
def give23
	2, 3

x, y: give23			## x = 2, y = 3    -or-
						## x = give23, y = nil		ie. Function Evaluation vs. Duplication

Static Typing ???  (Keep the syntax the same as Function Type Checking)
let x <- Int			## Primary Syntax
let x of Int			## Alt Syntax 1
let x :: Int			## Haskell. Philosophically we are "assigning" x to be an Int
## Any ideas for other alternates ???

x: 5					## 
x: 4					## The syntax clashes with constant declarations (but the type of constants isn't exactly flexible anyways)
x: "Hello"				## Throws a type error, "Hello" cannot be converted to an integer

Compound Assignment operators (Of the form <assignment><operator>, ie. :+, :-, :*)
x: 1					## Only add if it is possible to lex and parse correctly
for y in [1..5]
	x :+ 1				## x: x + 1

	Question: Would := be a viable compound operator
		x := z would read x: x = z
		Currently := is an assignment operator
		But the entire reasoning behind this was that ':' looked odd when the variable was a table field
			It still looks slightly odd, but I feel that that absurdity has passed once I've gotten used to the syntax

	Question: Would :=+ be valid syntax
		If I am to keep the rule general, yes
		However this doesn't look as nice

Variable Type Testing (testing against Int as an example) (keep the syntax of Static Typing and Function Type Checking and this the same)
	var <- Int					## the question is whether this version is viable or not
	var :: Int						## Haskell
	type(var) = "Int"			## this capability will be kept regardless (but there are problems with inheritance)
	is?(var, Int)				## from dust_test(deprecated) logic programming section (no problems with inheritance)