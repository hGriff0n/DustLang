Variable ssignment
	Style
		x: 5
	General feel
		Clean and concise assignment Syntax
		Intuitive syntax for non-array table keys
		Inconsistent feel when combined with 'let' and tables
	Consistency
		':' means always means assignment
		Assignment always entails ':'
	Flexibility
		Allows simple use of '=' for equality
	Cons
		No "good" way to have '+=' type operators
	Alternatives
		x = 5
		x := 5
		x <- 5
		5 -> x

let x: [4, y: 3]
z: [2, 3]
y: (x: 5) + 4			## Error: Reassignment of constant variable 'x'
y: (z: 5) + 4			## Valid: Variable 'z' is not marked constant
y: \ -> (x: 5) + 4			## Valid: Variable 'x' is in scope 'y' (lambda function)		Syntax will change

x, y: 3, 4				## Equivalent x: 3; y: 4


## EXAMPLE 3.2.4.
def give23
	2, 3

x, y: give23			## x = 2, y = 3    -or-
						## x = give23, y = nil		ie. Function Evaluation vs. Duplication

Static Typing ???  (Keep the syntax the same as Function Type Checking)
let x <- Int			## Primary Syntax
let x of Int			## Alt Syntax 1
## Any ideas for other alternates ???

x: 5					## 
x: 4					## The syntax clashes with constant declarations (but the type of constants isn't exactly flexible anyways)
x: "Hello"				## Throws a type error, "Hello" cannot be converted to an integer

Compound Assignment operators
x: 1					## Only add if it is possible to lex and parse correctly
for y in [1..5]
	x :+ 1				## x: x + 1

Variable Type Testing (the rightmost type is where the type name goes in actual code)
	var <- type					## the question is whether this version is viable or not (keep same syntax as Static Typing and Function Type Checking)
	type(var) = "type"			## this capability will be kept regardless (but there are problems with inheritance)
	is?(var, type)				## from dust_test (deprecated) logic programming section (no problems with inheritance)